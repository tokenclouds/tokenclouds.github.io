<!DOCTYPE html>
<html lang="en">
	<head>
    <meta charset="utf-8">
    <title>Scatterplot matrix</title>
    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="../d3.legend.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-latest.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

    <style type="text/css">
svg {
  font: 10px sans-serif;
  padding: 10px;
}

.axis,
.frame {
  shape-rendering: crispEdges;
}

.axis line {
  stroke: #ddd;
}

.axis path {
  display: none;
}

.frame {
  fill: none;
  stroke: #aaa;
}

path {
  fill-opacity: .8;
}

path.selected {
  fill-opacity: .2;
}

.extent {
  fill: #000;
  fill-opacity: .125;
  stroke: #fff;
}

.tooltip {
    position: absolute;
    width: 300px;
    height: 100px;
    font-size: 12px;
    pointer-events: none;
}

#wrap{
  border: 1px solid white;
  width: 600px;
}

div {
  float: left;
  margin-right: 10px;
}

.legend rect {
  fill:white;
  stroke:black;
  opacity:0.8;
}

</style>
</head>

<div id="wrap">
  <div>
  	<button type="button" class="btn btn-default" id="clear-select">Clear item selection</button>
  </div>
  <div class="dropdown"><button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown">Select colour<span class="caret"></span></button>
	  <ul class="dropdown-menu" id="colour"></ul>
  </div>
  <div class="dropdown"><button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown">Select shape<span class="caret"></span></button>
	  <ul class="dropdown-menu" id="shape"></ul>
  </div>
  <div class="dropdown"><button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown">Select size<span class="caret"></span></button>
	  <ul class="dropdown-menu" id="size"></ul>
  </div>
</div>

<div id="wrap">
  <div>
    Selection tool:
  <form>
    <label class="radio-inline"><input type="radio" name="optradio" id="brush-enab">brush</label>
    <label class="radio-inline"><input type="radio" name="optradio" id="click-select">click</label>
  </form>
  </div>
</div>

<div class="container">
  <h2></h2>
  <p></p>
</div>

<body>
<script>
var width = 2420,
    size = 375,
    padding = 30;

var x = d3.scale.linear()
    .range([padding / 2, size - padding / 2]);

var y = d3.scale.linear()
    .range([size - padding / 2, padding / 2]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .ticks(5);

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(5);

var color = d3.scale.category10();

// add the tooltip area to the webpage
var tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

var brushCell;

var type = window.location.pathname.split("/")[2]

var cset = (localStorage.getItem("cset"+"-"+type == null) ? [] : JSON.parse(localStorage.getItem("cset"+"-"+type)));
var shset = (localStorage.getItem("shset"+"-"+type == null) ? [] : JSON.parse(localStorage.getItem("shset"+"-"+type)));
var sset = (localStorage.getItem("sset"+"-"+type == null) ? [] : JSON.parse(localStorage.getItem("sset"+"-"+type)));

var modselection = JSON.parse(localStorage.getItem("modselection"+"-"+type));
var goToPlot = JSON.parse(localStorage.getItem("modselection"+"-"+type))[0];
var selection = (localStorage.getItem("selection"+"-"+type == null) ? [] : JSON.parse(localStorage.getItem("selection"+"-"+type)));

var dataset;

d3.tsv(type+".tsv", function(error, data) {
  dataset = data;
  // Extracts the first token name, assumes this is the type and sets it as the page title
  //var type = data[1]["_id"].match(/\w+\/\w+/)[0]
  //var type = window.location.pathname.split("/")[2]
  document.title = "Level 2: " + type + " scatterplot matrix";
  d3.select("body").select("h2").text("Level 2: " + type);
  d3.select("body").select("p").append("a").attr("href", "level1.html").text("up ");
  d3.select("body").select("p").append("a").attr("href", "level3.html").text(" down");

	colnames = d3.keys(data[0]);
	othercols = colnames.filter(function(d) {return (!d.endsWith(".x") && !d.endsWith(".y"))});
	firstRow = d3.entries(data[1]).filter(function(d) { if (othercols.indexOf(d.key) >= 0) {return d.value;}; });
	function isNumber(obj) { return !isNaN(parseFloat(obj)) }

	nominals = firstRow.filter(function(d) { if (!isNumber(d.value) && !d.key.startsWith("_")) { return d.key; } });
	var nomSet = new Set();
	nominals.forEach(function (d) { nomSet.add(new RegExp("([^.]+)$").exec(d.key)[0]); });

	numericals = firstRow.filter(function(d) { if (isNumber(d.value)) { return d.key; } });
	var numSet = new Set();
	numericals.forEach(function (d) { numSet.add(new RegExp("([^.]+)$").exec(d.key)[0]); });

	models = colnames.filter(function(d) { if (d.endsWith(".x")) { return d;} });

  var domainBySolution = {},
      rownames = d3.keys(data[0]).filter(function(d) { return d.indexOf(type) == 0; }),
      xnames = rownames.filter(function (d) { return d[d.length-1] == "x" })
	  console.log(modselection);
//      xnames.forEach(function(xname) {
//	         solutions.push(xname.substring(0, xname.length-2));
//           solutions = modselection;
//           solutions.reverse();
//      }),

	// Create selection menu for colour-coding
	var colourDropDown = d3.select("#colour")
		.attr("name", "Colour")
		.selectAll("option")
		.data(Array.from(nomSet))
		.enter()
		.append("li")
		.append("a")
		.attr("class", "col")
		.attr("xlink:href", "#")
		.attr("value", function (d) { return d; })
		.text(function (d) { return d; });

	var shapeDropDown = d3.select("#shape")
		.attr("name", "Shape")
		.selectAll("option")
		.data(Array.from(nomSet))
		.enter()
		.append("li")
		.append("a")
		.attr("class", "shape")
		.attr("xlink:href", "#")
		.attr("value", function (d) { return d; })
		.text(function (d) { return d; });

	// var sizeDropDown = d3.select("#size")
	// 	.attr("name", "Shape")
	// 	.selectAll("option")
	// 	.data(Array.from(numSet))
	// 	.enter()
	// 	.append("li")
	// 	.append("a")
	// 	.attr("class", "siz")
	// 	.attr("xlink:href", "#")
	// 	.attr("value", function (d) { return d; })
	// 	.text(function (d) { return d; });

	var modelDropDown = d3.select("#model")
		.attr("name", "Model")
		.selectAll("option")
		.data(models)
		.enter()
		.append("li")
		.append("a")
		.attr("class", "mod")
		.attr("xlink:href", "#")
		.attr("value", function(d) { return d.substring(0, d.length - 2); })
		.text(function (d) { return d.substring(0, d.length - 2); });


// Define the size of the matrix
      n = 3;

      modselection.forEach(function(solution) {
         domainBySolution[solution+".x"] = d3.extent(data, function(d) { return +d[solution+".x"]; });
         domainBySolution[solution+".y"] = d3.extent(data, function(d) { return +d[solution+".y"]; });
      });

      xAxis.tickSize(size * n);
      yAxis.tickSize(-size * n);

      var brush = d3.svg.brush()
          .x(x)
          .y(y)
          .on("brushstart", brushstart)
          .on("brush", brushmove)
          .on("brushend", brushend);

      var svg = d3.select("body").append("svg")
	     .attr("width", size * n + padding)
	     .attr("height", size * n + padding)
	     .append("g")
	     .attr("transform", "translate(" + padding + "," + padding / 2 + ")");

      svg.selectAll(".x.axis")
      .data(modselection)
      .enter().append("g")
      .attr("class", "x axis")
      .attr("transform", function(d, i) { return "translate(" + (n - i - 1) * size + ",0)"; })
      .each(function(d) { x.domain(domainBySolution[d+".x"]); d3.select(this).call(xAxis); });

      svg.selectAll(".y.axis")
      .data(modselection)
      .enter().append("g")
      .attr("class", "y axis")
      .attr("transform", function(d, i) { return "translate(0," + i * size + ")"; })
      .each(function(d) { y.domain(domainBySolution[d+".y"]); d3.select(this).call(yAxis); });


  var cell = svg.selectAll(".cell")
      .data(combine(modselection))
      .enter().append("g")
      .attr("class", "cell")
      .attr("transform", function(d) { return "translate(" + (n - +d.i - 1) * size + "," + +d.j * size + ")"; })
      .each(plot);

  cell.append("foreignObject")
  	.attr("x", size-padding-5)
	.attr("y", padding/2)
	.append("xhtml:body")
	.html("<form><input type=checkbox id=check checked=true></form>")
	.on("click", function(d,i) {
		model = d.x.substring(0, d.x.length-2);
		index = modselection.indexOf(model);
		if (index == -1) {
			modselection.push(model)
		} else {
			modselection.splice(index, 1)
		}
		localStorage.setItem("modselection"+"-"+type, JSON.stringify(modselection));
	});

// Titles for all plots.
  cell.append("text")
    .attr("x", padding)
    .attr("y", padding)
    .attr("dy", ".71em")
    .text(function(d) { if (d.x.substring(0, d.x.length-2) != "undefined") { return d.x.substring(0, d.x.length-2); }})
//    .on('click', function(d) {console.log(d.x.substring(0, d.x.length-2));});
    .on('click', function(d) {
      localStorage.setItem("goToPlot"+"-"+type, d.x.substring(0, d.x.length-2));
      window.location = "level3.html";
    });

    function clearBrush(){
      cell.selectAll('.brush').remove();
    }

    var brushEnab = false;
    d3.select("#brush-enab").on("change", function() {
              brushEnab = this.checked;
              if (brushEnab) {
                cell.append("g")
                  .attr("class", "brush")
                  .call(brush);
              } else {
//                location.reload();
                clearBrush();
				console.log("brush cleared");
              }
            });

  var clickSelect = false;
  d3.select("#click-select").on("change", function() {
    clickSelect = this.checked;
	brushEnab = false;
//	cell.remove("brush");
	clearBrush();
  });

  d3.select("#clear-select").on("click", function() {
    clearBrush();
    selection = []
    localStorage.setItem("selection"+"-"+type, JSON.stringify(selection));
    svg.selectAll(".selected").classed("selected", false);
    d3.selectAll('input').property('checked', false);
    clickSelect = false;
  });

  d3.selectAll(".col").on("click", function() {
	  cset = this.getAttribute("value");
	  localStorage.setItem("cset"+"-"+type, JSON.stringify(cset));
	  updatePlots();
  });

  d3.selectAll(".shape").on("click", function() {
	  shset = this.getAttribute("value");
	  localStorage.setItem("shset"+"-"+type, JSON.stringify(shset));
	  updatePlots();
  });

  d3.selectAll(".siz").on("click", function() {
	sset = this.getAttribute("value");
	localStorage.setItem("sset"+"-"+type, JSON.stringify(sset));
	updatePlots();
  });

  //Create color scale
  var getColors = d3.scale.category10();

  //Create dot size scale
  var getClustSize = d3.scale.sqrt();

  //Create shape scale
  var getShape = d3.scale.ordinal().range(["cross", "diamond", "square", "triangle-down", "triangle-up"]);

  // d3.select("#ldown").on("click", function() {
  //   window.location = "scatplot.html";
  // });

  function plot(p) {
    var cell = d3.select(this);
	getColors = d3.scale.category10();
	getShape = d3.scale.ordinal().range(["circle", "cross", "diamond", "square", "triangle-down", "triangle-up"]);
	getClustSize = d3.scale.sqrt();
    try {
    x.domain(domainBySolution[p.x]);
    y.domain(domainBySolution[p.y]);

    cell.append("rect")
        .attr("class", "frame")
        .attr("x", padding / 2)
        .attr("y", padding / 2)
        .attr("width", size - padding)
        .attr("height", size - padding);

    cell.selectAll("path")
        .data(data)
	    .enter()
		.append("path")
		.attr("transform", function(d) { return "translate(" + x(d[p.x]) + "," + y(d[p.y]) + ")"; })
		.attr("d", d3.svg.symbol()
			.type(function (d) { (shset === (undefined || null)) ? out="circle" : out=getShape(d[shset]); return out; })
			.size(function (d) { (sset === (undefined || null)) ? out=64 : out=getClustSize(+d[p.mod+"."+sset])*32; return out; }))
//		.attr("d", d3.svg.symbol("circle"))
		.style("fill", function(d) { (cset === (undefined || null)) ? out="#1f77b4" : out=getColors(d[cset]); return out; })
        .classed("selected", function(d) {
            if (selection.length > 0) {
             return !(selection.indexOf(d["_id"]) > -1);
           }
        })
        .attr("pointer-events", "all")
//        .on("click", scatterplot(p));
		.attr("data-legend", " ")
        .on("click", function(d) {
          if (clickSelect) {
            if (selection.indexOf(d["_id"]) === -1) {
                selection.push(d["_id"]);
                console.log("push " + d["_id"]);
          } else {
                var index = selection.indexOf(d["_id"]);
                if (index > -1) {
                  selection.splice(index, 1);
                }
                console.log("splice " + d["_id"]);
          }
            if (selection.length > 0) {
                svg.selectAll("path").classed("selected", function(d) {
                    return !(selection.indexOf(d["_id"]) > -1);
            })
          }
            localStorage.setItem("selection"+"-"+type, JSON.stringify(selection));
          }
          })
      } catch (e) {
        console.log("combinations missing " + e)
      }
  }

  // Clear the previously-active brush, if any.
  function brushstart(p) {
    if (brushCell !== this) {
      try {
      d3.select(brushCell).call(brush.clear());
      x.domain(domainBySolution[p.x]);
      y.domain(domainBySolution[p.y]);
      brushCell = this;
    } catch (e) {
      console.log("combinations missing")
    }
    }
  }

  // Highlight the selected paths.
  function brushmove(p) {
    var e = brush.extent();
//    console.log(e);
    svg.selectAll("path").classed("selected", function(d) {
      return e[0][0] > d[p.x] || d[p.x] > e[1][0]
          || e[0][1] > d[p.y] || d[p.y] > e[1][1];
    });
  }

  // If the brush is empty, select all paths.
  function brushend() {
    if (brush.empty()) {
      svg.selectAll(".selected").classed("selected", false);
    } else {
      selection = [];
      svg.selectAll("path").each(function(d) {
        if (!(d3.select(this).classed("selected"))) {
          if (selection.indexOf(d["_id"]) === -1) {
              selection.push(d["_id"]);
            }
          }
      });
      localStorage.setItem("selection"+"-"+type, JSON.stringify(selection));
    }
  }

  function combine(s) {
    var c = [], n = s.length, i, j, k = 0;
    for (j = -1; ++j < 3;) for (i = -1; ++i < 3;) if (k < n) c.push({mod: s[k], x: s[k]+".x", i: Math.abs(i-2), y: s[k]+".y", j: j}), ++k;
      return c;
    }

	console.log(combine(modselection));

  function updatePlots() {
	  // Refresh the scales
	  getColors = d3.scale.category10();
	  getClustSize = d3.scale.sqrt();
	  getShape = d3.scale.ordinal().range(["circle", "cross", "diamond", "square", "triangle-down", "triangle-up"]);
	  //Hide tooltip
	  svg.select("#tooltip").classed("selected", true);
	  d3.selectAll(".cell")
//	  	.data(combine(solutions))
	  	.selectAll("path")
			.attr("d", d3.svg.symbol()
				.type(function(d) { return getShape(d[shset]); }))
//				.size(function (d) { return getClustSize(+d[p.mod+"."+sset])*32; })
			.style("fill", function(d) { return getColors(d[cset]); })
			.attr("data-legend", function(d) { return d[cset]});

	  //Update legend or append if not created yet after necessary (!) delay
	  if (typeof cset !== "undefined") {
		  setTimeout(function() {
			  if (typeof legend !== "undefined") {
				  legend.call(d3.legend)
			  } else {
					  legend = svg.append("g")
						  .attr("class","legend")
						  .attr("transform","translate(0,0)")
						  .style("font-size","12px")
						  .call(d3.legend)
					  }
		  },100)
	  }
  }

// // d3.select('button').on('click', function() {
//   function scatplot(whatever) {
//     d3.select("svg").remove();
//     d3.select("div").remove();
//
//     // add the tooltip area to the webpage
//     var tooltip = d3.select("body").append("div")
//         .attr("class", "tooltip")
//         .style("opacity", 0);
//
//     var dataset;
//     d3.tsv("koper.tsv", function(data) {
//     dataset = data;
//
//     //Width and height
//     var width = 600;
//     var height = 600;
//     var padding = 30;
//
//     //Create scale functions
//     var xScale = d3.scale.linear()
//                .domain([d3.min(dataset, function(d) { return +d[whatever+".x"]; }) * 1.1, d3.max(dataset, function(d) { return +d[whatever+".x"]; }) * 1.1])
//                //								 .domain(d3.extent(dataset, function(d) { return +d["LeNC44.ppmi.x"]; }))
//                .range([padding, width - padding * 2]);
//
//     var yScale = d3.scale.linear()
//                .domain([d3.min(dataset, function(d) { return +d[whatever+".y"]; }) * 1.1, d3.max(dataset, function(d) { return +d[whatever+".y"]; }) * 1.1])
//                .range([height - padding, padding]);
//
//     //Define X axis
//     var xAxis = d3.svg.axis()
//               .scale(xScale)
//               .orient("bottom")
//               .ticks(10)
//               .outerTickSize(0);
//
//     //Define Y axis
//     var yAxis = d3.svg.axis()
//               .scale(yScale)
//               .orient("left")
//               .ticks(10)
//               .outerTickSize(0);
//
//     //Zoom
//     var zoom = d3.behavior.zoom()
//           .scaleExtent([1, 10])
//           .on("zoom", zoomed);
//
//     //Create SVG element
//     var svg = d3.select("body")
//           .append("svg")
//           .attr("width", width)
//           .attr("height", height)
//           .append("g")
//           .call(zoom);
//
//     var rect = svg.append("rect")
//           .attr("width", width)
//           .attr("height", height)
//           .style("fill", "none")
//           .style("pointer-events", "all");
//
//     var container = svg.append("g");
//
//     //Create color scale
//     var getColors = d3.scale.category10();
//
//     //Create dot size scale
//     var getClustSize = d3.scale.sqrt();
//
//     var brush = d3.svg.brush()
//         .x(xScale)
//         .y(yScale)
//         .on("brush", brushmove)
//         .on("brushend", brushend);
//
//     dot = container.append("g")
//        .attr("class", "dot")
//        .selectAll("path")
//        .data(dataset)
//        .enter()
//        .append("path")
//        .attr("cx", function(d) {
//           return xScale(+d[whatever+".x"]);
//        })
//        .attr("cy", function(d) {
//           return yScale(+d[whatever+".y"]);
//        })
//        .attr("r", function(d) {return getClustSize(+d[whatever+".maxW"]*5);})
// //				 .attr("r", 3)
//        .style("fill", function(d) { return getColors(d.label); })
//        .on("mouseover", function(d) {
//             tooltip.transition()
//               .duration(200)
//               .style("opacity", .9);
//               tooltip.html("<b>"+d["_id"]+"</b><br>"+d["_text"])
//               .style("left", (d3.event.pageX + 20) + "px")
//               .style("top", (d3.event.pageY - 28) + "px");
//     svg.selectAll("path").style("opacity", .2);
//     d3.select(this).attr("r", function(d) {return getClustSize(+d[whatever+".maxW"]*5);}).style("fill", "red").style("opacity", 1);
//         })
//         .on("mouseout", function(d) {
//             tooltip.transition()
//               .duration(500)
//               .style("opacity", 0);
//         svg.selectAll("path").attr("r", function(d) {return getClustSize(+d[whatever+".maxW"]*5);}).style("fill", function(d) { return getColors(d.label); }).style("opacity", 1);
//         });
//
//     //Create X axis
//     container.append("g")
//       .attr("class", "x axis")
//       .attr("transform", "translate(0," + (height - padding) + ")")
//       .call(xAxis);
//
//     //Create Y axis
//     container.append("g")
//       .attr("class", "y axis")
//       .attr("transform", "translate(" + padding + ",0)")
//       .call(yAxis);
//
//     function zoomed() {
//       container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
//     }
//
// //    container.append("g")
// //        .attr("class", "brush")
// //        .call(brush);
//
//     // Restore the previous brush selection
//     svg.selectAll("path").classed("hidden", function(d) {
//       return e[0][0] > +d[whatever+".x"] || +d[whatever+".x"] > e[1][0]
//       || e[0][1] > +d[whatever+".y"] || +d[whatever+".y"] > e[1][1];
//     });
//
//     // Highlight the selected paths.
//     function brushmove() {}
//
//     // If the brush is empty, select all paths.
//     function brushend() {
//       if (brush.empty()) svg.selectAll(".hidden").classed("hidden", false);
//     }
//
//
//     });
//   }

  d3.select(self.frameElement).style("height", size * n + padding + 20 + "px");

});

</script>
